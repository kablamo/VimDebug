#!/usr/bin/env perl
#
# vdd
# Vim Debugger Daemon
#
# (c) eric johnson 2002-3020
# email: vimDebug at iijo dot org
# http://iijo.org
# PODNAME: vdd
# ABSTRACT: The vdd program.

use strict;
use warnings;
use File::Basename;
use UNIVERSAL;
use POSIX ();

# constants
my $LINE_INFO      = "vimDebug:";
my $COMPILER_ERROR = "compiler error";
my $RUNTIME_ERROR  = "runtime error";
my $APP_EXITED     = "application exited";
my $DBGR_READY     = "debugger ready";

# global variables
my ($sessionId, $debuggerName, @debuggerCommand, $debugger);
my ($ctl_vddFIFOvim, $ctl_vimFIFOvdd, $dbg_vddFIFOvim);
my $debug_option = 0;
my $color_option = 0;



$SIG{INT} = \&signalHandler;
getCommandLineOptions();
init();
main();


sub signalHandler {
   exit;
}

sub getCommandLineOptions {
   usage() unless(scalar(@ARGV) >= 2);
   $sessionId       = shift @ARGV; # session id
   $debuggerName    = shift @ARGV; # which debugger to use
   @debuggerCommand = @ARGV;       # debugger command
}

sub usage {
   print << 'EOT';
Usage: vdd $sessionId $debugger $command

The vim debugger daemon uses the perl module
VimDebug::DebuggerInterface::$debugger to invoke
a debugger using the $command.

Communication with the daemon occurs via fifos located at:

   .ctl_vddFIFOvim.$sessionId
   .ctl_vimFIFOvdd.$sessionId
   .dbg_vddFIFOvim.$sessionId
EOT
   exit;
}

sub init {
   $| = 1;

   $ctl_vddFIFOvim = ".ctl_vddFIFOvim." . $sessionId;
   $ctl_vimFIFOvdd = ".ctl_vimFIFOvdd." . $sessionId;
   $dbg_vddFIFOvim = ".dbg_vddFIFOvim." . $sessionId;

   if ($color_option) {
      eval('require Term::ANSIColor;import Term::ANSIColor;') and
         warn "fancy color printing disabled.  couldn't find Term::ANSIColor\n";
   }
}

sub main {
   makeNamedPipe($ctl_vimFIFOvdd);
   makeNamedPipe($ctl_vddFIFOvim);
   makeNamedPipe($dbg_vddFIFOvim);
   startDebugger();

   # loop until request to exit
   while (1) {
      my $command = readFromVim();     # blocks until there is something to read

      for ($command) {   # this works like a switch statement
         /^break:(\d+):(.+)$/o     && act('setBreakPoint',   $1, $2) && last;
         /^clear:(\d+):(.+)$/o     && act('clearBreakPoint', $1, $2) && last;
         /^clearAll$/o             && act('clearAllBreakPoints')     && last;
         /^printExpression:(.+)$/o && act('printExpression', $1)     && last;
         /^command:(.+)$/o         && act('command', $1)             && last;
         /^(\w+)$/                 && act($1)                        && last;
         sendToVim("vdd: bad command");                                 last;
      }
   }
}

sub END {
   unlink $_ for $ctl_vimFIFOvdd, $ctl_vddFIFOvim, $dbg_vddFIFOvim;
}

sub makeNamedPipe {
   my $fifo = shift or die "gotta pass a fifo to this function";

   if (-p $fifo) {
      die "vdd: $fifo already exists.  perhaps another instance of" .
            " VimDebug is running?\nIf not, just delete $fifo.\n";
   }

   POSIX::mkfifo($fifo, 0700) or die "mkfifo $fifo failed: $!\n";
}

sub logger {
   my $printMe = shift or die;
   my $color   = (shift or color("blue"));

   $color_option ?
      print $color, $printMe, color("white"), "\n"
    : print "[" . $printMe . "]\n";
}



### debugger related subroutines ###############################################


# blocks until there is something to read
sub readFromVim {
   open(my $ctlHandle, "<", $ctl_vimFIFOvdd) or act('quit');
   my $from = <$ctlHandle>;
   close($ctlHandle);
   logger("received '$from'") if $debug_option;
   return $from;
}

# blocks until someone reads
sub sendToVim {
   my $stuffToSend = shift;
   my $debugOutput = shift;

   logger("sending  '$stuffToSend'") if $debug_option;
   open(my $ctlHandle, ">", $ctl_vddFIFOvim) or act('quit');
   print {$ctlHandle} $stuffToSend;
   close($ctlHandle);

   logger("sending  '$debugOutput'") if $debug_option;
   open(my $dbgHandle, ">", $dbg_vddFIFOvim) or act('quit');
   print {$dbgHandle} $debugOutput;
   close($dbgHandle);
}

sub startDebugger {

   # load module
   my $moduleName = 'VimDebug/DebuggerInterface/' . $debuggerName . '.pm';
   require $moduleName ;

   # create debugger object
   $debuggerName = 'VimDebug::DebuggerInterface::' . $debuggerName;
   $debugger = eval $debuggerName . "->new();";
   die "no such module exists: $debuggerName" unless defined $debugger;

   act("startDebugger", @debuggerCommand);
}

sub act {
   my $action  = shift or die;
   my @options = @_;

   if (! UNIVERSAL::can($debugger, $action)) {
      sendToVim("vdd: bad command", "\n");
      return 1;
   }

   my $rv = eval '$debugger->' . $action . '(@options);';
   if ($action eq 'quit') {
      exit();
   }
   elsif (defined $debugger->lineNumber and defined $debugger->filePath) {
      sendToVim(
         $LINE_INFO . $debugger->lineNumber . ":" . $debugger->filePath, 
         $debugger->output
      );
   }
   else {
      sendToVim($DBGR_READY, $debugger->output);
   }

   return 1;
}

